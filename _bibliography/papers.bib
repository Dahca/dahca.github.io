---
notes: https://github.com/inukshuk/jekyll-scholar
---

@inproceedings{neal2017TheAO,
  title={{The Advantages of a Transactional Interface: Porting Applications to TxFS}},
  author={Ian Neal},
  booktitle={The University of Texas at Austin Department of Computer Science},
  month={may},
  year={2017},

  selected={false},
  type={thesis},
  abbr={Honors Thesis},
  pdf={honors_thesis.pdf},
  url={https://apps.cs.utexas.edu/apps/tech-reports/27249},
  abstract={In this paper I explore the value of transactional file systems by showing how such systems can benefit existing applications while not adding additional complexity to the codebase. I first discuss the concept of transactions in computing and how transactional semantics are used to provide consistency and durability to an application’s state. I examine a new work developed at the University of Texas, TxFS, which provides a very simple and powerful transactional interface. I then introduce how existing systems can be modified to take advantage of TxFS by modifying SQLite, a widely used embedded database, and by modifying OpenLDAP, a widely used implementation of the Lightweight Directory Access Protocol. These modified systems benefit from running on TxFS by having a simplified transactional system, reduced locking, no user-level logging, and enhanced support for multithreaded operations. Additionally, I show how simple it is to port existing systems to TxFS, and demonstrate how easy it would be for other systems to adopt TxFS to ensure durability and consistency for their users.}

}

@inproceedings{hu2018txfs,
  title={{TxFS: Leveraging File-System Crash Consistency to Provide ACID Transactions}},
  author={Hu, Yige and Zhu, Zhiting and Neal, Ian and Kwon, Youngjin and Cheng, Tianyu and Chidambaram, Vijay and Witchel, Emmett},
  booktitle={Proceedings of the 2018 USENIX Conference on Usenix Annual Technical Conference},
  pages={879--891},
  year={2018},
  month={jul},

  selected={false},
  type={peer-reviewed},
  abbr={ATC'18},
  url={https://www.usenix.org/conference/atc18/presentation/hu},
  pdf={txfs.pdf},
  abstract={We introduce TxFS, a novel transactional file system that builds upon a file system's atomic-update mechanism such as journaling. Though prior work has explored a number of transactional file systems, TxFS has a unique set of properties: a simple API, portability across different hardware, high performance, low complexity (by building on the journal), and full ACID transactions. We port SQLite and Git to use TxFS, and experimentally show that TxFS provides strong crash consistency while providing equal or better performance.}
}

@inproceedings{weisse2019nda,
  title={NDA: Preventing speculative execution attacks at their source},
  author={Weisse, Ofir and Neal, Ian and Loughlin, Kevin and Wenisch, Thomas F and Kasikci, Baris},
  booktitle={Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture},
  pages={572--586},
  year={2019},
  month={oct},
  
  selected={false},
  type={peer-reviewed},
  abbr={MICRO'19},
  url={https://dl.acm.org/doi/abs/10.1145/3352460.3358306},
  pdf={nda.pdf},
  abstract={Speculative execution attacks like Meltdown and Spectre work by accessing secret data in wrong-path execution. Secrets are then transmitted and recovered by the attacker via a covert channel. Existing mitigations either require code modifications, address only specific exploit techniques, or block only the cache covert channel. Rather than battling exploit techniques and covert channels one by one, we seek to close off speculative execution attacks at their source. Our key observation is that these attacks require a chain of dependent wrong-path instructions to access and transmit secret data. We propose NDA, a technique to restrict speculative data propagation. NDA breaks the attacks' wrong-path dependence chains while still allowing speculation and dynamic scheduling. We describe a design space of NDA variants that differ in the constraints they place on dynamic scheduling and the classes of speculative execution attacks they prevent. NDA preserves much of the performance advantage of out-of-order execution: on SPEC CPU 2017, NDA variants close 68-96% of the performance gap between in-order and unconstrained (insecure) out-of-order execution.}
}

@inproceedings {neal2020agamotto,
  author = {Ian Neal and Ben Reeves and Ben Stoler and Andrew Quinn and Youngjin Kwon and Simon Peter and Baris Kasikci},
  title = {{AGAMOTTO: How Persistent is your Persistent Memory Application?}},
  booktitle = {14th {USENIX} Symposium on Operating Systems Design and Implementation ({OSDI} 20)},
  year = {2020},
  isbn = {978-1-939133-19-9},
  pages = {1047--1064},
  publisher = {{USENIX} Association},
  month = nov,

  selected={true},
  type={peer-reviewed},
  abbr={OSDI'20},
  url={https://www.usenix.org/conference/osdi20/presentation/neal},
  pdf={agamotto.pdf},
  awards={Awarded IEEE Micro Top Picks 2021 Honorable Mention!},
  abstract={Persistent Memory (PM) can be used by applications to directly and quickly persist any data structure, without the overhead of a file system. However, writing PM applications that are simultaneously correct and efficient is challenging. As a result, PM applications contain correctness and performance bugs. Prior work on testing PM systems has low bug coverage as it relies primarily on extensive test cases and developer annotations.

  In this paper we aim to build a system for more thoroughly testing PM applications. We inform our design using a detailed study of 63 bugs from popular PM projects. We identify two application-independent patterns of PM misuse which account for the majority of bugs in our study and can be detected automatically. The remaining application-specific bugs can be detected using compact custom oracles provided by developers.

  We then present AGAMOTTO, a generic and extensible system for discovering misuse of persistent memory in PM applications. Unlike existing tools that rely on extensive test cases or annotations, AGAMOTTO symbolically executes PM systems to discover bugs. AGAMOTTO introduces a new symbolic memory model that is able to represent whether or not PM state has been made persistent. AGAMOTTO uses a state space exploration algorithm, which drives symbolic execution towards program locations that are susceptible to persistency bugs. AGAMOTTO has so far identified 84 new bugs in 5 different PM applications and frameworks while incurring no false positives.}
}

@misc{wozniak2020user,
  title={User-specific video frame brightness filter},
  author={Wozniak, Matthew Richard and Kucukgoz, Mehmet and Pollock, Holly Helene and Neal, Ian Glen and Vertido, Rafael Vincent Prieto},
  year={2020},
  month=sep # "~15",
  publisher={Google Patents},
  note={US Patent 10,778,932},

  type={patent},
  url={https://patents.google.com/patent/US10778932B2/en}
}

@misc{wozniak2020video,
  title={Video frame brightness filter},
  author={Wozniak, Matthew Richard and Kucukgoz, Mehmet and Pollock, Holly Helene and Neal, Ian Glen and Vertido, Rafael Vincent Prieto},
  year={2020},
  month=jun # "~11",
  publisher={Google Patents},
  note={US Patent App. 16/210,380},

  type={patent},
  url={https://patents.google.com/patent/US20200184247A1/en}
}

@misc{wozniak2020color,
  title={Color-specific video frame brightness filter},
  author={Wozniak, Matthew Richard and Kucukgoz, Mehmet and Pollock, Holly Helene and Neal, Ian Glen and Vertido, Rafael Vincent Prieto},
  year={2020},
  month=jun # "~11",
  publisher={Google Patents},
  note={US Patent App. 16/210,667},

  type={patent},
  url={https://patents.google.com/patent/US20200186764A1/en}
}

@inproceedings {neal2021rethinking,
  title = {{Rethinking File Mapping for Persistent Memory}},
  booktitle = {19th {USENIX} Conference on File and Storage Technologies ({FAST} 21)},
  author={Ian Neal and Gefei Zuo and Eric Shiple and Tanvir Ahmed Khan and Youngjin Kwon and Simon Peter and Baris Kasikci},
  year = {2021},
  url = {https://www.usenix.org/conference/fast21/presentation/neal},
  publisher = {{USENIX} Association},
  month = feb,

  type={peer-reviewed},
  abbr={FAST'21},
  selected={true},
  pdf={fast21-neal.pdf},
  abstract={Persistent main memory (PM) dramatically improves IO performance. We find that this results in file systems on PM spending as much as 70% of the IO path performing file mapping (mapping file offsets to physical locations on storage media) on real workloads. However, even PM-optimized file systems perform file mapping based on decades-old assumptions. It is now critical to revisit file mapping for PM.

  We explore the design space for PM file mapping by building and evaluating several file-mapping designs, including different data structure, caching, as well as meta-data and block allocation approaches, within the context of a PM-optimized file system. Based on our findings, we design HashFS, a hash-based file mapping approach. HashFS uses a single hash operation for all mapping and allocation operations, bypassing the file system cache, instead prefetching mappings via SIMD parallelism and caching translations explicitly. HashFS’s resulting low latency provides superior performance compared to alternatives. HashFS increases the throughput of YCSB on LevelDB by up to 45% over page-cached extent trees in the state-of-the-art Strata PM-optimized file system.}
}

@inproceedings{neal2021towards,
  title = {{Towards Bug-free Persistent Memory Applications}},
  author={Neal, Ian and Quinn, Andrew and Kasikci, Baris},
  booktitle = {{12th Non-Volatile Memories Workshop (NVMW'21)}},
  year = {2021},
  month = mar,

  pdf={nvmw2021-paper38-final.pdf},
  type={workshop},
  url={http://nvmw.ucsd.edu/program/#paper-38},
  abbr={NVMW'21},
  abstract={Persistent Memory (PM) aims to revolutionize the storage-memory hierarchy, but programming these systems is error-prone. Our work investigates how to to help developers write better, bug-free PM applications by automatically debugging them. We first perform a study of bugs in persistent memory applications to identify the opportunities and pain-points of debugging these systems. Then, we discuss our work on AGAMOTTO, a generic and extensible system for automatically detecting PM bugs. Unlike existing tools that rely on extensive test cases or annotations, AGAMOTTO automatically detects bugs in PM systems by extending symbolic execution to model persistent memory. AGAMOTTO has so far identified 84 new bugs in 5 different PM applications and frameworks while incurring no false positives. We then discuss HIPPOCRATES, a system that automatically fixes bugs in PM systems. HIPPOCRATES “does no harm”: its fixes are guaranteed to fix an PM bug without introducing new bugs. We show that HIPPOCRATES produces fixes that are functionally equivalent to developer fixes and that HIPPOCRATES fixes have performance that rivals manually-developed code.},

}

@inproceedings {neal2021hippocrates,
  title = {{HIPPOCRATES: Healing Persistent Memory Bugs Without Doing Any Harm}},
  booktitle = {Proceedings of the Twenty-Sixth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)},
  author={Ian Neal and Andrew Quinn and Baris Kasikci},
  year = {2021},
  url = {https://dl.acm.org/doi/abs/10.1145/3445814.3446694},
  publisher = {Association for Computing Machinery},
  month = apr,

  type={peer-reviewed},
  abbr={ASPLOS'21},
  selected={true},
  ext_abs={hippo_ea.pdf},
  pdf={hippocrates.pdf},
  abstract={Persistent memory (PM) technologies aim to revolutionize storage
  systems, providing persistent storage at near-DRAM speeds. Alas,
  programming PM systems is error-prone, as the misuse or omission
  of the durability mechanisms (i.e., cache flushes and memory fences)
  can lead to durability bugs (i.e., unflushed updates in CPU caches
  that violate crash consistency). PM-specific testing and debugging
  tools can help developers find these bugs, however even with such
  tools, fixing durability bugs can be challenging. To determine the
  reason behind this difficulty, we first study durability bugs and
  find that although the solution to a durability bug seems simple,
  the actual reasoning behind the fix can be complicated and timeconsuming. 
  Overall, the severity of these bugs coupled with the
  difficultly of developing fixes for them motivates us to consider
  automated approaches to fixing durability bugs.
  We introduce Hippocrates, a system that automatically fixes
  durability bugs in PM systems. Hippocrates automatically performs the complex 
  reasoning behind durability bug fixes, relieving
  developers of time-consuming bug fixes. Hippocrates's fixes are
  guaranteed to be safe, as they are guaranteed to not introduce new
  bugs (``do no harm''). We use Hippocrates to automatically fix 23
  durability bugs in real-world and research systems. We show that
  Hippocrates produces fixes that are functionally equivalent to developer fixes. 
  We then show that solely using Hippocrates’s fixes,
  we can create a PM port of Redis which has performance rivaling
  and exceeding the performance of a manually-developed PM-port
  of Redis.}
}

@inproceedings {khan2021dmon,
author = {Tanvir Ahmed Khan and Ian Neal and Gilles Pokam and Barzan Mozafari and Baris Kasikci},
title = {{DMon: Efficient Detection and Correction of Data Locality Problems using Selective Profiling}},
booktitle = {15th {USENIX} Symposium on Operating Systems Design and Implementation ({OSDI} 21)},
year = {2021},
publisher = {{USENIX} Association},
month = jul,

selected={false},
type={peer-reviewed},
url={https://www.usenix.org/conference/osdi21/presentation/khan},
pdf={dmon.pdf},
abbr={OSDI'21},
abstract={Poor data locality hurts an application’s performance. While 
compiler-based techniques have been proposed to improve data locality, 
they depend on heuristics, which can sometimes hurt performance. Therefore,
developers typically find data locality issues via dynamic profiling and repair them manually. Alas, existing profiling techniques incur high overhead and cannot be deployed in production, where programs may exhibit previously-unseen performance problems.

We present selective profiling, a technique that locates data locality problems with low-enough overhead that is suitable for production use. To achieve low overhead, selective profiling gathers runtime execution information selectively and incrementally. Using selective profiling, we build DMon, a system that can automatically locate data locality problems in production, identify access patterns that hurt locality, and repair such patterns using targeted optimizations.

Thanks to selective profiling, DMon’s profiling overhead is 1.36% on average, making it feasible for production use. DMon’s targeted optimizations provide 16.83% speedup on average (up to 53.14%), compared to a baseline that uses the highest level of compiler optimization. DMon speeds up PostgreSQL, one of the most popular database systems, by 6.64% on average (up to 17.48%).}
}

@inproceedings{loughlin2021dolma,
  title = {{DOLMA: Securing Speculation with the Principle of Transient Non-Observability}},
  author={Loughlin, Kevin and Neal, Ian and Ma, Jiacheng and Tsai, Elisa and Weisse, Ofir and Narayanasamy, Satish and Kasikci, Baris},
  booktitle = {30th {USENIX} Security Symposium ({USENIX} Security 21)},
  year = {2021},
  address = {Vancouver, B.C.},
  publisher = {{USENIX} Association},
  month = aug,

  pdf={dolma.pdf},
  type={peer-reviewed},
  url={https://www.usenix.org/conference/usenixsecurity21/presentation/loughlin},
  abbr={USENIX Sec'21},
  abstract={Modern processors allow attackers to leak data during transient 
  (i.e., mis-speculated) execution through microarchitectural covert timing 
  channels. While initial defenses were channel-specific, recent solutions 
  employ speculative information flow control in an attempt to automatically 
  mitigate attacks via any channel. However, we demonstrate that the current 
  state-of-the-art defense fails to mitigate attacks using speculative stores, 
  still allowing arbitrary data leakage during transient execution. Furthermore, 
  we show that the state of the art does not scale to protect data in registers, 
  incurring 30.8–63.4% overhead on SPEC 2017, depending on the threat model.

  We then present DOLMA, the first defense to automatically provide 
  comprehensive protection against all known transient execution attacks. 
  DOLMA combines a lightweight speculative information flow control scheme with 
  a set of secure performance optimizations. By enforcing a novel principle of 
  transient non-observability, DOLMA ensures that a time slice on a core 
  provides a unit of isolation in the context of existing attacks. Accordingly,
  DOLMA can allow speculative TLB/L1 cache accesses and variable-time arithmetic
  without loss of security. On SPEC 2017, DOLMA achieves comprehensive
  protection of data in memory at 10.2–29.7% overhead, adding protection for
  data in registers at 22.6–42.2% overhead (8.2–21.2% less than the state of
  the art, with greater security).},


}

